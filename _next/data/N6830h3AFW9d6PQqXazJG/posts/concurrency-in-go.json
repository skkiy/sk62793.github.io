{"pageProps":{"postData":{"id":"concurrency-in-go","contentHtml":"<h1>GO言語による並行処理</h1>\n<h1>1章 並行処理入門</h1>\n<p>並行処理とは：一つ以上の処理が同時に発生する処理</p>\n<p>クラウドコンピューティングによってコードを並行にするかという問題が生まれた\n→Webスケール：驚異的並列化可能な問題\n→ローリングアップデート、水平スケールが可能に</p>\n<h2>並行処理の難しさ</h2>\n<h3>競合状態</h3>\n<p>データ競合：同じ変数に読み込みと書き込みが同時に起こる</p>\n<h3>アトミック性</h3>\n<p>アトミック性：それが操作されている特定のコンテキスト（スコープ、操作がアトミックであると考えられる範囲）の中では分割不能、或いは中断不可であること</p>\n<p>分割不能、中断不可：コンテキストの中で、何かアトミックな処理が起きた場合には、そのコンテキスト全体で処理をしていて、その他の何かが同時には起きていない</p>\n<h3>メモリアクセス同期</h3>\n<p>クリティカルセクション：プログラム内で共有リソースに対する排他的なアクセスが必要な場所</p>\n<p>メモリへの同期的アクセスによって解決できるわけではない</p>\n<h3>デッドロック</h3>\n<p>全ての並行なプロセスがお互いの処理を待ち合っている状況</p>\n<p>検知するためのissue(https://github.com/golang/go/issues/13759)</p>\n<p>Coffman条件\n相互排他：ある並行プロセスがリソースに対して排他的な権利をどの時点においても保持している。\n条件待ち：ある並行プロセスはリソースの保持と追加のリソース待ちを同時に行わなければならない。\n横取り不可：ある並行プロセスによって保持されているリソースは、ソロプロセスによって飲み解放される。\n循環待ち：ある並行プロセス（P1）は、他の連なっている並行プロセス（P2）を待たなければならない。そしてP2はP1を待っている。</p>\n<h3>ライブロック</h3>\n<p>並行操作を行なっているけど、その操作はプログラムの状態を全く進めていないプログラム\n廊下で人同士（複数のgoroutine）がお互いに道を譲ろうとして（デッドロックを予防して）いる状態</p>\n<h3>リソース枯渇</h3>\n<p>並行プロセスが仕事をするのに必要なリソースを取得できない状況\nあるゴルーチンが不必要にクリティカルセクションを超えて共有ロックを広げ、他のゴルーチンが効率的に仕事をできない状態\n検知するにはログを出力して、仕事の速度が期待通りになっているかを測定する</p>\n<h3>安全性</h3>\n<p>並行処理が関わる問題空間で関数、メソッド、変数を公開する場合は、以下の3点に触れる。\n・誰が並行処理を担っているか。\n・問題空間がどのように並行処理のプリミティブに対応しているか。\n・誰が同期処理を担っているか。</p>\n<h1>2章 並行性をどうモデル化するか：CSPとは何か</h1>\n<h2>並行性と並列性の違い</h2>\n<p>並行性はコードの性質を指し、並列性は動作しているプログラムの性質を指す。</p>\n<h2>CSP(Communicating Sequential Processes)</h2>\n<p>独立したプロセス群がメッセージパッシングによって通信することで相互にやりとりしているもの\nGoではCSPを言語仕様として採用しているため、読み書き、理解のコストが低くなっている</p>\n<p>通信によってメモリを共有し、メモリの共有によって通信してはいけない</p>\n<p>プリミティブを使うか、チャネルを使うかの判断基準\n・データの所有権を移動しようとしているか\n・構造体の内部の状態を保護しようとしているか\n・複数のロジックを強調させようとしているか\n・パフォーマンスクリティカルセクションか</p>\n<h1>3章 Goにおける並行処理の構成要素</h1>\n<h3>ゴルーチン</h3>\n<p>一時停止や再エントリーのポイントは提供されておらず、ランタイムによって自動的に行われる\nゴルーチンがブロックしたときにのみ割り込まれる</p>\n<p>OSスレッド、グリーンスレッド\nM:Nスケジューラー（M個のグリーンスレッドをN個のOSスレッドに対応させるもの）</p>\n<p>fork-joinモデル：プログラムが子の処理を分岐させて、親と並行に実行させること。この処理が親に再度合流する場所を合流ポイントと呼ぶ。</p>\n<p>合流ポイントの作成のためにsync.WaitGroupを使うことができる。</p>\n<p>ゴルーチンは軽量</p>\n<p>コンテキストスイッチ\n別の並行プロセスに切り替えるために状態を保存する必要がある</p>\n<h3>syncパッケージ</h3>\n<p>処理の完了を待つ</p>\n<h3>MutexとRWMutex</h3>\n<p>相互排他、メモリに対する同期アクセスの慣習を作る</p>\n<h3>Cond</h3>\n<p>ゴルーチンが待機したりイベントの発生を知らせるためのランデブーポイント</p>\n<p>条件が起きるのを待っている間ロックをずっと保持しているわけではない</p>\n<p>Signalはシグナルを一番長く待っているゴルーチンにシグナルを伝える\nBroadcastはシグナルを待っている全てのゴルーチンにシグナルを伝える</p>\n<h3>Once</h3>\n<p>Doに渡された関数が異なるゴルーチンで呼ばれたとしても一度しか実行されないようにする</p>\n<h3>Pool</h3>\n<p>コストが高いものを作るときに数を制限して、決まった数しか作られないようにしつつ、予測できない数の操作がこれらにアクセスをリクエストできるようにする。複数のゴルーチンから安全に使うことができる。</p>\n<h3>Channel</h3>\n<p>読み取り用チャネルから2つ目の戻り値を受け取ることができ、読み込みできたかどうか、閉じたチャネルから生成されたデフォルト値のいずれかを示す。</p>\n<p>チャネルを閉じるにはcloseを使う</p>\n<p>rangeを使うと、チャネルが閉じたときに自動的にループを終了する</p>\n<p>バッファ付きチャネル\n読み込みが行われなくても書き込み可能な回数を増やす</p>\n<p>チャネルを所有するゴルーチンが踏むべき手順\n・チャネルを初期化する\n・書き込みを行うか、他のゴルーチンに所有権を渡す\n・チャネルを閉じる\n・上の3つの手順をカプセルかして読み込みチャネルを経由して公開する</p>\n<p>チャネルの消費者\n・チャネルがいつ閉じられたかを把握する\n・ブロックする操作は責任をもって扱う</p>\n<pre><code>chanOwner := func() &#x3C;- chan int {\n\tresultStream := make(chan int, 5)\n\tgo func() {\n\t\tdefer close(resultStream)\n\t\tfor i := 0; i &#x3C;= 5; i++ {\n\t\t\tresultStream &#x3C;- i\n\t\t}\n\t}()\n\treturn resultStream\n}\n\nresultStream := chanOwner()\nfor result := range resultStream {\n\tfmt.Printf(\"Received: %d\\n\", result)\n}\nfmt.Println(\"Done receiving!\")\n</code></pre>\n<h3>select</h3>\n<p>キャンセル処理、タイムアウト、待機、デフォルト値といった概念とチャネルを安全にまとめる</p>\n<p>複数のチャネルが同時に読み込めるようになったときは、疑似乱数による一様選択をする</p>\n<p>タイムアウトにはtime.After関数を使える</p>\n<h3>GOMAXPROCSレバー</h3>\n<p>ワークキューと呼ばれるOSスレッドの数を制御している</p>\n<h1>4章 Goでの並行処理パターン</h1>\n<h2>拘束</h2>\n<p>情報をたった一つの平行プロセスからのみ得られることを確実にする考え方</p>\n<p>アドホック拘束\n拘束を規約によって達成した場合（静的解析）</p>\n<p>レキシカル拘束\nレキシカルスコープを使って適切なデータと並行処理のプリミティブだけを複数の平行プロセスが使えるように公開すること（コンパイラ）</p>\n<h2>for-selectループ</h2>\n<p>・チャネルからくりかえしの変数を送出する</p>\n<pre><code>for _, s := range []string{\"a\", \"b\", \"c\"} {\n\tselect {\n\tcase &#x3C;- done:\n\t\treturn\n\tcase stringStream &#x3C;- s:\n\t}\n}\n</code></pre>\n<p>・停止シグナルを待つ無限ループ</p>\n<pre><code>for {\n\tselect {\n\tcase &#x3C;- done:\n\t\treturn\n\tdefault:\n\t}\n}\n</code></pre>\n<h2>ゴルーチンリークを避ける</h2>\n<p>ゴルーチンが終了する場合\n・ゴルーチンが処理を完了する場合\n・回復できないエラーにより処理を続けられない場合\n・停止するように命令された場合</p>\n<p>ゴルーチンの親子間で親から子にキャンセルのシグナルを送れるようにする</p>\n<pre><code>doWork := func(\n\tdone &#x3C;- chan interface{},\n\tstrings &#x3C;- chan string,\n) &#x3C;- chan interface {} {\n\tterminated := make(chan interface{})\n\tgo func() {\n\t\tdefer fmt.Println(\"doWork exited.\")\n\t\tdefer close(terminated)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase s := strings:\n\t\t\t\tfmt.Printlne(s)\n\t\t\tcase &#x3C;- done:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\treturn terminated\n}\n\ndone := make(chan interface{})\nterminated := doWork(done, nil)\n\ngo func() {\n\ttime.Sleep(1 * time.Second)\n\tfmt.Println(\"Canceling doWork goroutine...\")\n\tclose(done)\n}()\n\n&#x3C;-terminated\nfmt.Println(\"Done.\")\n</code></pre>\n<pre><code>newRandStream := func(done &#x3C;- chan interface{}) &#x3C;- chan int {\n\trandStream := make(chan int)\n\tgo func() {\n\t\tdefer fmt.Println(\"newRandStream closure exited.\")\n\t\tdefer close(randStream)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase randStream &#x3C;- rand.Int():\n\t\t\tcase &#x3C;- done:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\treturn randStream\n}\n\ndone := make(chan interface{})\nrandStream := newRandStream(done)\nfmt.Println(\"3 random ints:\")\nfor i := 1; i &#x3C;= 3; i++ {\n\tfmt.Printf(\"%d: %d\\n\", i, &#x3C;- randStream)\n}\nclose(done)\n</code></pre>\n<h2>orチャネル</h2>\n<pre><code>var or func(channels ...&#x3C;-chan interface{}) &#x3C;-chan interface{}\nor = func(channels ...&#x3C;-chan interface{}) &#x3C;-chan interface{} {\n\tswitch len(channels) {\n\tcase 0:\n\t\treturn nil\n\tcase 1:\n\t\treturn channels[0]\n\t}\n\n\torDone := make(chan interface{})\n\tgo func() {\n\t\tdefer close(orDone)\n\t\tswitch len(channels) {\n\t\tcase 2:\n\t\t\tselect {\n\t\t\tcase &#x3C;-channels[0]:\n\t\t\tcase &#x3C;-channels[1]:\n\t\t\t}\n\t\tdefault:\n\t\t\tselect {\n\t\t\tcase &#x3C;-channels[0]:\n\t\t\tcase &#x3C;-channels[1]:\n\t\t\tcase &#x3C;-channels[2]:\n\t\t\tcase &#x3C;-or(append(channels[3:], orDone)...):\n\t\t\t}\n\t\t}\n\t}()\n\treturn orDone\n}\n\nsig := func(after time.Duration) &#x3C;-chan interface{} {\n\tc := make(chan interface{})\n\tgo func() {\n\t\tdefer close(c)\n\t\ttime.Sleep(after)\n\t}()\n\treturn c\n}\n\nstart := time.Now()\n&#x3C;-or(\n\tsig(2*time.Hour),\n\tsig(5*time.Minute),\n\tsig(1*time.Second),\n\tsig(1*time.Hour),\n\tsig(1*time.Minute),\n)\nfmt.Printf(\"done after %v\", time.Since(start))\n</code></pre>\n<h2>エラーハンドリング</h2>\n<p>https://www.ymotongpoo.com/works/goblog-ja/post/erros-are-values/</p>\n<p>誰がそのエラーを処理する責任を持つべきか</p>\n<p>並行プロセスはエラーを、プログラムの状態を完全に把握していて何をすべきかをより多くの情報に基づいて決定的できる別の箇所へと送るべき</p>\n<pre><code>type Result struct {\n\tError error\n\tResponse *http.Response\n}\n\ncheckStatus := func(done &#x3C;-chan interface{}, urls ...string) &#x3C;-chan Result {\n\tresults := make(chan Result)\n\tgo func() {\n\t\tdefer close(results)\n\n\t\tfor _, url := range urls {\n\t\t\tvar result Result\n\t\t\tresp, err := http.Get(url)\n\t\t\tresult = Result{Error: err, Response: resp}\n\t\t\tselect {\n\t\t\tcase &#x3C;-done:\n\t\t\t\treturn\n\t\t\tcase results &#x3C;-result:\n\t\t\t}\n\t\t}\n\t}()\n\treturn results\n}\n\ndone := make(chan interface{})\ndefer close(done)\n\nurls := []string{\"https://www.google.com\", \"https://badhost\"}\nfor result := range checkStatus(done, urls...) {\n\tif result.Error != nil {\n\t\tfmt.Printf(\"error: %v\", result.Error)\n\t\tcontinue\n\t}\n\tfmt.Printf(\"Response: %v\\n\", result.Response.Status)\n}\n</code></pre>\n<h2>パイプライン</h2>\n<p>データを受け取って、何らかの処理を行なって、どこかに渡すという一連の作業</p>\n<p>ステージの性質\n・受け取るものと返すものが同じ型\n・弾き回せるように具体化されている</p>\n<p>バッチ処理とストリーム処理</p>\n<h3>パイプライン構築のためのベストプラクティス</h3>\n<pre><code>geenrator := func(done &#x3C;-chan interface{}, integers ...int) &#x3C;-chan int {\n\tintStream := make(chan int, len(integers))\n\tgo func() {\n\t\tdefer close(intStream)\n\t\tfor _, i := range integers {\n\t\t\tselect {\n\t\t\tcase &#x3C;-done:\n\t\t\t\treturn\n\t\t\tcase intStream &#x3C;- i:\n\t\t\t}\n\t\t}\n\t}()\n\treturn intStream\n}\n\nmultiply := func(\n\tdone &#x3C;-chan interface{},\n\tintStream &#x3C;-chan int,\n\tmultipier int,\n) &#x3C;-chan int {\n\tmultipliedStream := make(chan int)\n\tgo func() {\n\t\tdefer close(multipliedStream)\n\t\tfor i := range intStream {\n\t\t\tselect {\n\t\t\tcase &#x3C;-done:\n\t\t\t\treturn\n\t\t\tcase multipliedStream &#x3C;- i*multiplier:\n\t\t\t}\n\t\t}\n\t}()\nreturn multipliedStream\n}\n\nadd := func(\n\tdone &#x3C;-chan interface{},\n\tintStream &#x3C;-chan int,\n\tadditive int,\n) &#x3C;-chan int {\n\taddedStream := make(chan int)\n\tgo func() {\n\t\tdefer close(addedStream)\n\t\tfor i := range(intStream) {\n\t\t\tselect {\n\t\t\tcase &#x3C;-done:\n\t\t\t\treturn\n\t\t\tcase addedStream &#x3C;- i+additive:\n\t\t\t}\n\t\t}\n\t}()\n\treturn addedStream\n}\n\ndone := make(chan interface{})\ndefer close(done)\n\nintStream := generator(done, 1, 2, 3, 4)\npipeline := multiply(done, add(done, multiply(done, intStream, 2), 1), 2)\n\nfor v := range pipeline {\n\tfmt.Printlne(v)\n}\n</code></pre>\n<pre><code>repeat := func(\n\tdone &#x3C;-chan interface{},\n\tvalues ...interface{},\n) &#x3C;-chan interface{} {\n\tvalueStream := make(chan interface{})\n\tgo func() {\n\t\tdefer close(valueStream)\n\t\tfor {\n\t\t\tfor _, v := range values {\n\t\t\t\tselect {\n\t\t\t\tcase &#x3C;- done:\n\t\t\t\t\treturn\n\t\t\t\tcase valueStream &#x3C;- v:\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\treturn valueStream\n}\n\ntake := func(\n\tdone &#x3C;-chan interface{},\n\tvalueStream &#x3C;-chan interface{},\n\tnum int,\n) &#x3C;- chan interface{} {\n\ttakeStream := make(chan interface{})\n\tgo func() {\n\t\tdefer close(takeStream)\n\t\t\n\t\tfor i := 0; i &#x3C; num; i++ {\n\t\t\tselect {\n\t\t\tcase &#x3C;-done:\n\t\t\t\treturn\n\t\t\tcase takeStream &#x3C;- &#x3C;- valueStream:\n\t\t\t}\n\t\t}\n\t}()\n\treturn takeStream\n}\n\ndone := make(chan interface{})\ndefer close(done)\n\nfor num := range take(done, repeat(done, 1), 10) {\n\tfmt.Printf(\"%v \", num)\n}\n\nrepeatFn := func(\n\tdone &#x3C;-chan interface{},\n\tfn func() interface{},\n) &#x3C;-chan interface{} {\n\tvalueStream := make(chan interface{})\n\tgo func() {\n\t\tdefer close(valueStream)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase &#x3C;-done:\n\t\t\t\treturn\n\t\t\tcase valueStream &#x3C;- fn():\n\t\t\t}\n\t\t}\n\t}()\n\treturn valueStream\n}\n\ndone := make(chan interface{})\ndefer close(done)\n\nrand := func() interface{} { return rand.Int() }\n\nfor num := range take(done, repeatFn(done, rand), 10) {\n\tfmt.Println(num)\n}\n\ntoString := func(\n\tdone &#x3C;-chan interfacce{},\n\tvalueStream &#x3C;-chan interface{},\n) &#x3C;-chan string {\n\tstringStream := make(chan string)\n\tgo func() {\n\t\tdefer close(stringStream)\n\t\tfor v := range valueStream {\n\t\t\tselect {\n\t\t\tcase &#x3C;-done:\n\t\t\t\treturn\n\t\t\tcase stringStream &#x3C;- v.(string):\n\t\t\t}\n\t\t}\n\t}()\n\treturn stringStream\n}\n\ndone := make(chan interface{})\ndefer close(done)\n\nvar message string\nfor token := range toString(done, take(done, repeat(done, \"I\", \"am.\"), 5)) {\n\tmessage += token\n}\n\nfmt.Printf(\"message: %s...\", message)\n</code></pre>\n<h2>ファンアウト、ファンイン</h2>\n<p>ファンアウト：パイプラインからの入力を扱うために複数のゴルーチンを起動するプロセス\n利用すべき条件\n・そのステージがより前の計算結果に依存していない\n・実行が長時間に及ぶ</p>\n<p>ファンイン：複数の結果を一つのチャネルに結合するプロセス</p>\n<h2>or-doneチャネル</h2>\n<pre><code>orDone := func(done, c &#x3C;-chan interface{}) &#x3C;-chan interface{} {\n\tvalStream := make(chan interface{})\n\tgo func() {\n\t\tdefer close(valStream)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase &#x3C;-done:\n\t\t\t\treturn\n\t\t\tcase v, ok := &#x3C;-c:\n\t\t\t\tif ok == false {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase valStream &#x3C;- v:\n\t\t\t\tcase &#x3C;-done:\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\treturn valStream\n}\n\nfor val := range orDone(done, myChan) {\n}\n</code></pre>\n<h2>teeチャネル</h2>\n<p>チャネルからのストリームを2つに分け、同じ値を2つの異なる場所で使う場合</p>\n<pre><code>tee := func(\n\tdone &#x3C;-chan interface{},\n\tin &#x3C;-chan interface{},\n) (_, _ &#x3C;-chan interface{}) {\n\tout1 := make(chan interface{})\n\tout2 := make(chan interface{})\n\tgo func() {\n\t\tdefer close(out1)\n\t\tdefer close(out2)\n\t\tfor val := range orDone(done, in) {\n\t\t\tvar out1, out2 = out1, out2\n\t\t\tfor i := 0; i &#x3C; 2; i++ {\n\t\t\t\tselect {\n\t\t\t\tcase out1&#x3C;-val:\n\t\t\t\t\tout1 = nil\n\t\t\t\tcase out2&#x3C;-val:\n\t\t\t\t\tout2 = nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\treturn out1, out2\n}\n\ndone := make(chan interface{})\ndefer close(done)\n\nout1, out2 := tee(done, take(done, repeat(done, 1, 2), 4))\n\nfor val1 := range out1 {\n\tfmt.Printf(\"out1: %v, out2: %v\\n\", val1, &#x3C;-out2)\n}\n</code></pre>\n<h2>bridgeチャネル</h2>\n<p>チャネルのシーケンスから値を消費する場合</p>\n<pre><code>bridge := func(\n\tdone &#x3C;-cahn interface{},\n\tchanStream &#x3C;- chan &#x3C;-chan interface{},\n) &#x3C;-chan interface{} {\n\tvalStream := make(chan interface{})\n\tgo func() {\n\t\tdefer close(valStream)\n\t\tfor {\n\t\t\tvar stream &#x3C;-chan interface{}\n\t\t\tselect {\n\t\t\tcase maybeStream, ok := &#x3C;-chanStream:\n\t\t\t\tif ok == false {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tstream = maybeStream\n\t\t\t}\n\t\t\tcase &#x3C;-done:\n\t\t\t\treturn\n\t\t}\n\t\tfor val := range orDone(done, stream) {\n\t\t\tselect {\n\t\t\tcase valStream &#x3C;- val:\n\t\t\tcase &#x3C;-done:\n\t\t\t}\n\t\t}\n\t}()\n\treturn valStream\n}\n\ngenVals := func() &#x3C;-chan &#x3C;-chan interface{} {\n\tchanStream := make(chan (&#x3C;-chan interface{}))\n\tgo func() {\n\t\tdefer close(chanStream)\n\t\tfor i := 0; i &#x3C; 10; i++ {\n\t\t\tstream := make(chan interface{}, 1)\n\t\t\tstream &#x3C;- i\n\t\t\tclose(stream)\n\t\t\tchanStream &#x3C;- stream\n\t\t}\n\t}()\n\treturn chanStream\n}\n\nfor v := range bridge(nil, genVals()) {\n\tfmt.Printf(\"%v \", v)\n}\n</code></pre>\n<h2>キュー</h2>\n<p>プログラム最適化の最後に導入すべき\n導入すべき状況\n・ステージ内でのバッチによるリクエストが時間を節約する場合\n・ステージにおける遅延がシステムにフィードバックループを発生させる場合</p>\n<p>ステージを分離できる</p>\n<h2>contextパッケージ</h2>\n<p>2つの目的\n・コールグラフの各枝をキャンセルするAPIを提供する\n・コールグラフを通じてリクエストに関するデータを渡すデータの置き場所を提供する</p>\n<p>WithValueとValue\n・使用するキーは比較可能性を満たさなければならない\n・返された値は複数の後ルーチンからアクセスされても安全でなければならない</p>\n<pre><code>func main() {\n\tProcessRequest(\"jane\", \"abc134\")\n}\n\ntype ctxKey int\n\nconst (\n\tctxUserID ctxKey = iota\n\tctxAuthToken\n)\n\nfunc UserID(c context.Context) string {\n\treturn c.Value(ctxUserID).(string)\n}\n\nfunc AuthToken(c context.Context) string {\n\treturn c.Value(ctxAuthToken).(string)\n}\n\nfunc ProcessRequest(userID, authToken string) {\n\tctx := context.WithValue(context.Background(), ctxUserID, userID)\n\tctx = context.WithValue(ctx, ctxAuthToken, authToken)\n\tHandleResponse(ctx)\n}\nfunc HandleResponse(ctx context.Context) {\n\tfmt.Printf(\n\t\t\"handling response for %v (auth: %v)\",\n\t\tUserID(ctx),\n\t\tAuthToken(ctx),\n\t)\n}\n</code></pre>\n<p>コンテキスト値はプロセスやAPIの境界を通過するリクエストスコープでのデータに絞って使いましょう。\n関数にオプションのパラメーターを渡すために使うべきではありません。</p>\n<p>・データはプロセスやAPIの境界を通過すべき\n・データは不変であるべき\n・データは単純な型に向かっていくべき\n・データはデータであるべきでメソッド付きの型であるべきではない\n・データは修飾の操作を助けるべきものであって、それを駆動するものではない</p>\n<h1>5章 大規模開発での並行処理</h1>\n<h2>エラー伝播</h2>\n<p>エラーに必要な情報\n・何が起きたのか\n・いつどこでエラーが発生したか\n・ユーザー向けの読みやすいメッセージ\n・ユーザーがさらに情報を得るにはどうするべきか</p>\n<p>各コンポーネントの教会では、下から上がってきたエラーは自分のコンポーネント向けにきちんとした形のエラーになるように包んで整えてやらなければならない</p>\n<h2>タイムアウトとキャンセル処理</h2>\n<p>タイムアウトするべき理由</p>\n<p>システム飽和状態\n・リクエストがタイムアウトしたときに重複しなさそうな場合\n・リクエストを保存するリソースがない場合（例：インメモリキュー用のメモリ、永続キュー用のディスク容量）\n・リクエストやリクエストが送っているデータが処理待ちをしている間に古くなってしまった場合</p>\n<p>新鮮でないデータ</p>\n<p>デッドロックを防ぐ試み\nシステムがデッドロックに陥らないよう保証するために全ての並列処理にタイムアウトを設定するのは推奨されている。</p>\n<p>キャンセル処理するべき理由</p>\n<p>タイムアウト</p>\n<p>ユーザーによる介入\nプロセスの状態を確認できるようにすること、ユーザーに起動した処理をキャンセルできるようにすること</p>\n<p>親のキャンセル</p>\n<p>複製されたリクエスト\n複数の並行処理のプロセスに、どれかが早くレスポンスを返してくれることを期待して、複製したデータを送り、最初の1つが返ってきたとき</p>\n<p>並行処理のプロセスが割り込み可能になる期間を定めること\nこの期間よりも長くかかりそうな機能は確実にそれ自身を割り込み可能にすること</p>\n<p>子のステージがメッセージを受け取った後で、親のステージがキャンセル処理のメッセージを受け取ったとき、このステージが複製されたメッセージを受け取る可能性がある\n→複製されたメッセージを送らないようにする方法\n・ステージ間で双方向のやりとりを行う（ハートビート）\n・最初か最後に報告された結果だけを受け入れる\n・親のゴルーチンに対しポーリングして許可を得る</p>\n<h2>ハートビート</h2>\n<p>並行処理のプロセスが生きていることを外に伝える方法（k8sではどう実装してるんだろ）</p>\n<p>・一定周期で発生するハートビート</p>\n<pre><code>doWork := func(\n\tdone &#x3C;-chan interface{},\n\tpulseInterval time.Duration,\n) (&#x3C;-chan interface{}, &#x3C;-chan time.Time) {\n\theartbeat := make(chan interface{})\n\tresults := make(chan time.Time)\n\tgo func() {\n\t\tdefer close(heartbeat)\n\t\tdefer close(results)\n\n\t\tpulse := time.Tick(pulseInterval)\n\t\tworkGen := time.Tick(2*pulseInterval)\n\n\t\tsendPulse := func() {\n\t\t\tselect {\n\t\t\tcase heartbeat &#x3C;-struct{}{}:\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t\tsendResult := func(r time.Time) {\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase &#x3C;-done:\n\t\t\t\t\treturn\n\t\t\t\tcase &#x3C;-pulse:\n\t\t\t\t\tsendPulse()\n\t\t\t\tcase results &#x3C;- r:\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase &#x3C;-done:\n\t\t\t\treturn\n\t\t\tcase &#x3C;-pulse:\n\t\t\t\tsendPulse()\n\t\t\tcase r := &#x3C;-workGen:\n\t\t\t\tsendResult(r)\n\t\t\t}\n\t\t}\n\t}()\n\treturn heartbeat, results\n}\n\ndone := make(chan interface{})\ntime.AfterFunc(10*time.Second, func() { close(done) })\n\nconst timeout = 2*time.Second\nheartbeat, results := doWork(done, timeout/2)\nfor {\n\tselect {\n\tcase _, ok := &#x3C;-heartbeat:\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\t\tfmt.Println(\"pulse\")\n\tcase r, ok := ,-results:\n\t\tif ok == false {\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"results %v\\n\", r.Second())\n\tcase &#x3C;-time.After(timeout):\n\t\treturn\n\t}\n}\n</code></pre>\n<p>・仕事単位の最初に発生するハートビート</p>\n<pre><code>doWork := func(done &#x3C;-chan interface{}) (&#x3C;-chan interface{}, &#x3C;-chan int) {\n\theartbeatStream := make(chan interface{}, 1)\n\tworkStream := make(chan int)\n\tgo func() {\n\t\tdefer close(heartbeatStream)\n\t\tdefer close(workStream)\n\n\t\tfor i := 0; i &#x3C; 10; i++ {\n\t\t\tselect {\n\t\t\tcase heartbeatStream &#x3C;- struct{}{}:\n\t\t\tdefault:\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase &#x3C;-done:\n\t\t\t\treturn\n\t\t\tcase workStream &#x3C;- rand.Intn(10):\n\t\t\t}\n\t\t}\n\t}()\n\treturn heartbeatStream, workStream\n}\n\ndone := make(chan interface{})\ndefer close(done)\n\nheartbeat, results := doWork(done)\nfor {\n\tselect {\n\tcase _, ok := &#x3C;-heartbeat:\n\t\tif ok {\n\t\t\tfmt.Println(\"pulse\")\n\t\t} else {\n\t\t\treturn\n\t\t}\n\tcase r, ok := &#x3C;-results:\n\t\tif ok {\n\t\t\tfmt.Printf(\"results %v\\n\", r)\n\t\t} else {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc TestDoWork_GenerateAllNumbers(t *testing.T) {\n\tdone := make(chan interface{})\n\tdefer close(done)\n\n\tintSlice := []int{0, 1, 2, 3, 5}\n\theartbeat, results := DoWork(done, intSlice...)\n\n\t&#x3C;-heartbeat\n\n\ti := 0\n\tfor r := range results {\n\t\tif expected := intSlice[i]; r != expected {\n\t\t\tt.Errorf(\"index %v: expected %v, but received %v,\", i, expected, r)\n\t\t}\n\t}\n}\n</code></pre>\n<h2>複製されたリクエスト</h2>\n<p>レスポンスをできる限り速く受け取ることが最優先であるとき\nハンドラーが処理のために使うリソースは同様に複製する必要がありコストがかかる</p>\n<h2>流量制限</h2>\n<p>トークンバケット\nアクセストークンを持ってリソースを利用する\n所持できるトークンの数（バケットの深さ）とトークンが補充される速度によって、制限する</p>\n<h2>不健全なゴルーチンを直す</h2>\n<pre><code>type startGoroutineFn func(\n\tdone &#x3C;-chan interface{},\n\tpulseInterval time.Duration,\n) (heartbeat &#x3C;-chan interface{})\n\nnewSteward := func(\n\ttimeout time.Duration,\n\t startGoroutine startGoroutineFn,\n) startGoroutineFn {\n\treturn func(\n\t\tdone &#x3C;-chan interface{},\n\t\tpulseInterval time.Duration,\n\t) (&#x3C;-chan interface{}) {\n\t\theartbeat := make(chan interface{})\n\t\tgo func() {\n\t\t\tdefer close(heartbeat)\n\n\t\t\tvar wardDone chan interface{}\n\t\t\tvar wardHeartbeat &#x3C;-chan interface{}\n\t\t\tstartWard := func() {\n\t\t\t\twardDone = make(chan interface{})\n\t\t\t\twardHeartbeat = startGoroutine(or(wardDone, done), timeout/2)\n\t\t\t}\n\t\t\tstartWard()\n\t\t\tpulse := time.Tick(pulseInterval)\n\n\t\tmonitorLoop:\n\t\t\tfor {\n\t\t\t\ttimeoutSignal := time.After(timeout)\n\n\t\t\t\tfor {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase &#x3C;-pulse:\n\t\t\t\t\t\tselect {\n\t\t\t\t\t\tcase heartbeat &#x3C;- struct{}{}:\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t}\n\t\t\t\t\tcase &#x3C;-wardHeartbeat:\n\t\t\t\t\t\tcontinue monitorLoop\n\t\t\t\t\tcase &#x3C;-timeoutSignal:\n\t\t\t\t\t\tlog.Println(\"steward: ward unhealthy; restarting\")\n\t\t\t\t\t\tclose(wardDone)\n\t\t\t\t\t\tstartWard()\n\t\t\t\t\t\tcontinue monitorLoop\n\t\t\t\t\tcase &#x3C;-done:\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\treturn heartbeat\n\t}\n}\n</code></pre>\n<pre><code>doWorkFn := func(\n\tdone &#x3C;-chan interface{},\n\tintList ...int\n) (startGoroutineFn, &#x3C;-chan interface{}) {\n\tintChanStream := make(chan (&#x3C;-chan interface{}))\n\tintStream := bridge(done, intChanStream)\n\tdoWork := func(\n\t\tdone &#x3C;-chan interface{},\n\t\tpulseInterval time.Duration,\n\t) &#x3C;-chan interface{} {\n\t\tintStream := make(chan interface{})\n\t\theartbeat := make(chan interface{})\n\t\tgo func() {\n\t\t\tdefer close(intStream)\n\t\t\tselect {\n\t\t\tcase intChanStream &#x3C;- intStream:\n\t\t\tcase &#x3C;-done:\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tpulse := time.Tick(pulseInterval)\n\n\t\t\tfor {\n\t\t\t\tvalueLoop:\n\t\t\t\tfor _, intVal := range intList {\n\t\t\t\t\tif intVal &#x3C; 0 {\n\t\t\t\t\t\tlog.Printf(\"negative value :%V\\n\", intVal)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tfor {\n\t\t\t\t\t\tselect {\n\t\t\t\t\t\tcase &#x3C;-pulse:\n\t\t\t\t\t\t\tselect {\n\t\t\t\t\t\t\tcase heartbeat &#x3C;- struct{}{}:\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase intStream &#x3C;- intVal:\n\t\t\t\t\t\t\tcontinue valueLoop\n\t\t\t\t\t\tcase &#x3C;-done:\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\treturn heartbeat\n\t}\n\treturn doWork, intStream\n}\n\ndone := make(chan interface{})\ndefer close(done)\n\ndoWork, intStream := doWorkFn(done, 1, 2, -1, 3, 4, 5)\ndoWorkWithSteward := newSteward(1*time.Millisecond, doWork)\ndoWorkWithSteward(done, 1*time.Hour)\n\nfor intVal := range take(done, intStream, 6) {\n\tfmt.Printf(\"Received: %v\\n\", intVal)\n}\n</code></pre>\n<h1>6章 ゴルーチンとGoランタイム</h1>\n<h2>ワークスティーリング</h2>\n<p>フェアスケジューリング：各プロセッサーが平等に同数のタスク数を持つような戦略\n→使用率が高くないプロセッサーが出てしまう可能性がある\n→あるタスクが他のプロセッサーで稼働しているタスクと同じデータを必要としていたりするのでキャッシュの局所性が乏しくなることがある</p>\n<p>ワークスティーリングアルゴリズム</p>\n<ol>\n<li>分岐地点では、タスクをそのスレッドに紐づいているデックの最後尾に追加します</li>\n<li>そのスレッドがアイドルなときは、ほかの任意のスレッドに紐づいたデックの先頭から処理を盗みます</li>\n<li>まだ実現していない合流地点（未達の合流地点、つまり、同期しているゴルーチンがまだ完了していない）において、そのスレッドが持っているデックの最後尾からタスクを取り出します</li>\n<li>もしスレッドのデックが空ならば次のどちらかを行います。\na. 合流地点で停止する</li>\n</ol>\n<p>b. 任意のスレッドに紐付いたデックの先頭からタスクを盗む</p>\n<p>最後尾のタスクはほぼ間違いなく親の合流を完了させるために必要になる</p>\n<p>最後尾のタスクはほぼ間違いなく依然としてプロセッサーのキャッシュにある</p>\n<p>継続スティーリング\nゴルーチンではなく、継続をデックに入れる</p>\n<p>G：ゴルーチン\nM：OSスレッド（マシン）\nP：コンテキスト（プロセッサー）</p>\n","title":"Concurrency in Go","date":"2021-12-01"}},"__N_SSG":true}